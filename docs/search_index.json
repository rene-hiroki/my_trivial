[["index.html", "日々の雑学 はじめに 0.1 環境", " 日々の雑学 Akiyama Hiroki 最終更新日: 2020-12-20 はじめに 作成中です hogehoge fugafuga 0.1 環境 sessionInfo() ## R version 4.0.3 (2020-10-10) ## Platform: x86_64-w64-mingw32/x64 (64-bit) ## Running under: Windows 10 x64 (build 18363) ## ## Matrix products: default ## ## locale: ## [1] LC_COLLATE=Japanese_Japan.932 LC_CTYPE=Japanese_Japan.932 LC_MONETARY=Japanese_Japan.932 ## [4] LC_NUMERIC=C LC_TIME=Japanese_Japan.932 ## ## attached base packages: ## [1] stats graphics grDevices utils datasets methods base ## ## other attached packages: ## [1] here_1.0.1 bookdown_0.21.4 janitor_2.0.1 forcats_0.5.0 stringr_1.4.0 dplyr_1.0.2 ## [7] purrr_0.3.4 readr_1.4.0 tidyr_1.1.2 tibble_3.0.4 ggplot2_3.3.2 tidyverse_1.3.0 ## [13] magrittr_2.0.1 ## ## loaded via a namespace (and not attached): ## [1] tidyselect_1.1.0 xfun_0.19 haven_2.3.1 snakecase_0.11.0 ## [5] colorspace_2.0-0 vctrs_0.3.5 generics_0.1.0 htmltools_0.5.0.9002 ## [9] yaml_2.2.1 utf8_1.1.4 rlang_0.4.9 pillar_1.4.7 ## [13] glue_1.4.2 withr_2.3.0 DBI_1.1.0 dbplyr_2.0.0 ## [17] modelr_0.1.8 readxl_1.3.1 lifecycle_0.2.0 munsell_0.5.0 ## [21] gtable_0.3.0 cellranger_1.1.0 rvest_0.3.6 htmlwidgets_1.5.3 ## [25] evaluate_0.14 knitr_1.30 crosstalk_1.1.0.1 fansi_0.4.1 ## [29] broom_0.7.3 Rcpp_1.0.5 scales_1.1.1 backports_1.2.0 ## [33] DT_0.16 jsonlite_1.7.2 fs_1.5.0 hms_0.5.3 ## [37] digest_0.6.27 stringi_1.5.3 grid_4.0.3 rprojroot_2.0.2 ## [41] cli_2.2.0 tools_4.0.3 crayon_1.3.4 pkgconfig_2.0.3 ## [45] ellipsis_0.3.1 xml2_1.3.2 reprex_0.3.0 lubridate_1.7.9.2 ## [49] assertthat_0.2.1 rmarkdown_2.6 httr_1.4.2 rstudioapi_0.13 ## [53] R6_2.5.0 compiler_4.0.3 "],["01_android_analysis.html", "Chapter: 1 android分析 1.1 ライブラリの準備 1.2 activityをダウンロード 1.3 ここから解析", " Chapter: 1 android分析 1.1 ライブラリの準備 pacman::p_loadを使うと、ライブラリをまとめて読み込んでくれます。また、インストールされていないライブラリがある場合は、インストールかつ読み込みを行ってくれます。 pacmanがインストールされていない場合は、コメントアウトしてインストールしてください。 # install.packages(pacman) pacman::p_load(tidyverse, jsonlite, patchwork, here, lubridate, update = FALSE) 1.2 activityをダウンロード あとで書く google takeout で検索 1.3 ここから解析 1.3.1 activityの読み込み android &lt;- jsonlite::fromJSON(here(&quot;data/android_activity.json&quot;)) 1.3.2 読み込んだactivityデータの概要確認 glimpse(android) ## Rows: 63,120 ## Columns: 5 ## $ header [3m[38;5;246m&lt;chr&gt;[39m[23m &quot;びよーんったー Pro&quot;, &quot;Nova Launcher ホーム&quot;, &quot;Gmail&quot;, &quot;Slack&quot;, &quot;Nova Launcher ホーム&quot;, &quot;com.an... ## $ title [3m[38;5;246m&lt;chr&gt;[39m[23m &quot;使用: びよーんったー Pro&quot;, &quot;使用: Nova Launcher ホーム&quot;, &quot;使用: Gmail&quot;, &quot;使用: Slack&quot;, &quot;使用: Nova La... ## $ titleUrl [3m[38;5;246m&lt;chr&gt;[39m[23m &quot;https://play.google.com/store/apps/details?id=com.ABS104a.biyontterpro&quot;, &quot;https:/... ## $ time [3m[38;5;246m&lt;chr&gt;[39m[23m &quot;2020-04-16T21:29:57.048Z&quot;, &quot;2020-04-16T21:29:54.832Z&quot;, &quot;2020-04-16T21:29:28.111Z&quot;... ## $ products [3m[38;5;246m&lt;list&gt;[39m[23m [&quot;Android&quot;, &quot;Android&quot;, &quot;Android&quot;, &quot;Android&quot;, &quot;Android&quot;, &quot;Android&quot;, &quot;Android&quot;, &quot;An... 1.3.3 timeデータを変換 android &lt;- android %&gt;% mutate(time = parse_datetime(time, locale = locale(tz = &quot;Japan&quot;)) ) %&gt;% mutate(date = lubridate::date(time), year = lubridate::year(time)) 1.3.4 年月ごとのデータ数の集計 2018年8月以前のデータが少ない。 activityデータの収集がうまくいっていなかった？ android %&gt;% group_by(year, month(date)) %&gt;% count() ## # A tibble: 37 x 3 ## # Groups: year, month(date) [37] ## year `month(date)` n ## &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 2016 12 2 ## 2 2017 1 1 ## 3 2017 2 56 ## 4 2017 3 26 ## 5 2017 5 6 ## 6 2017 6 64 ## 7 2017 7 12 ## 8 2017 8 29 ## 9 2017 9 32 ## 10 2017 11 4 ## # ... with 27 more rows android %&gt;% count(date) %&gt;% ggplot() + geom_line(aes(date,n)) + scale_x_date(breaks = &quot;month&quot;, guide = guide_axis(n.dodge = 3)) 1.3.5 データの準備 2019年と2020年のデータのみを使うことにする。 android_latest &lt;- android %&gt;% filter(year %in% c(2019, 2020)) アプリの名前が長いから20文字までにする。 android_latest &lt;- android_latest %&gt;% mutate(header = if_else(str_length(header) &gt;= 20, substr(header, 1, 20), header)) android &lt;- android %&gt;% mutate(header = if_else(str_length(header) &gt;= 20, substr(header, 1, 20), header)) 1.3.6 アプリの使用回数（2019-2020） android_latest %&gt;% count(header, sort = TRUE) %&gt;% head(5) %&gt;% mutate(header = fct_reorder(header, n)) %&gt;% ggplot() + geom_col(aes(y = header, x = n)) + theme_minimal() + labs(title = &quot;Most used Apps - Overall&quot;, subtitle = &quot;Android Smartphone usage&quot;, caption = &quot;Data:Google Takeout&quot;) 1.3.7 アプリの使用回数（すべての年） android %&gt;% count(header, sort = TRUE) %&gt;% head(5) %&gt;% mutate(header = fct_reorder(header, n)) %&gt;% ggplot() + geom_col(aes(y = header, x = n)) + theme_minimal() + labs(title = &quot;Most used Apps - Overall&quot;, subtitle = &quot;Android Smartphone usage&quot;, caption = &quot;Data:Google Takeout&quot;) 1.3.8 比較（2019 vs 2020） android_latest %&gt;% filter(year %in% &#39;2019&#39;) %&gt;% group_by(year, header) %&gt;% summarise(n = n()) %&gt;% arrange(desc(n)) %&gt;% head(5) %&gt;% #View() mutate(header = fct_reorder(header, n)) %&gt;% ggplot() + geom_col(aes(y = header, x = n)) + # facet_wrap(~year, scales = &quot;free&quot;) + theme_minimal() + labs(title = &quot;Most used Apps - 2019&quot;, subtitle = &quot;Android Smartphone usage&quot;, caption = &quot;Data:Google Takeout&quot;) -&gt; p2019 ## `summarise()` regrouping output by &#39;year&#39; (override with `.groups` argument) android_latest %&gt;% filter(year %in% &#39;2020&#39;) %&gt;% group_by(year, header) %&gt;% summarise(n = n()) %&gt;% arrange(desc(n)) %&gt;% head(5) %&gt;% #View() mutate(header = fct_reorder(header, n)) %&gt;% ggplot() + geom_col(aes(y = header, x = n)) + # facet_wrap(~year, scales = &quot;free&quot;) + theme_minimal() + labs(title = &quot;Most used Apps - 2020&quot;, subtitle = &quot;Android Smartphone usage&quot;, caption = &quot;Data:Google Takeout&quot;) -&gt; p2020 ## `summarise()` regrouping output by &#39;year&#39; (override with `.groups` argument) p2019 / p2020 "],["02_standard_input.html", "Chapter: 2 標準入力 2.1 readLines 2.2 スクリプトで計算処理 2.3 テキストファイルを読ませる", " Chapter: 2 標準入力 標準入力、つまりはPythonで言うところのinput()をRでやろうとしたら、かなり苦労したのでtipsとしてまとめておくことにした。 2.1 readLines ずばりRで標準入力をするにはreadLinesを使う。ただし、 input_lines &lt;- readLines(&quot;stdin&quot;) このように\"stdin\"という引数を使用する。おそらくstandard input の略か何かだろう。 注意すべきは、このコードをRのコンソールで実行してしまうとRがうんともすんとも言わなくなってしまうこと。 詳しい理由はわからないが、コマンドプロンプトからの標準入力を受けるように指示しているので、コンソールで実行してしまうとダメ、ということなのだろうか（誰か教えて欲しい）。 コンソール上で実験的にコードを試したい場合は、readline()を使えばコンソールで入力待ち状態となるので、こちらを使用する。 たとえばstdin.Rに下記のように記述しておき、 #! /usr/bin/env Rscript input_lines &lt;- readLines(&quot;stdin&quot;) cat(input_lines[1]) # catは標準出力 コマンドプロンプトから下記のようにしてstdin.Rを実行してみる Rscript stdin.R すると入力待ち状態になるので、何かしら記述する。 Hello world! そして、ctrl + cあるいはctrl + zの後にEnterで入力を終了すると（他の方法ありますか？） Hello world! とプロンプトに標準出力ができる。 2.2 スクリプトで計算処理 stdin.Rに以下のように記述しておけば、標準入力で受け取った値を、計算処理をしてから返すこともできる。 #! /usr/bin/env Rscript # ライブラリもつかえる library(tidyverse) input_lines &lt;- readLines(&quot;stdin&quot;) x = as.integer(input_lines[1]) # 1つめ（1行目の入力） y = as.integer(input_lines[2]) # 2つめ cat(x + y) 2.3 テキストファイルを読ませる read_text.txtを別に以下のように準備しておき、 （read_text.txtの最終行には改行を入れないと、あとでwarningが出るので注意する。） Hello world! stdin.Rをこうしておく #! /usr/bin/env Rscript input_lines &lt;- readLines(&quot;stdin&quot;) x = input_lines[1] y = input_lines[2] cat(x, y) そしてコマンドプロンプトで次のようにすれば、read_text.txtから標準入力を受け取ることができる。 Rscript stdin.R &lt; read_text.txt プロンプトの出力はこうなる Hello world! これでatcoderにも参戦できる！ （atcoderでRは使用不可、、、） "],["03_ido_keido.html", "Chapter: 3 緯度経度からちょっとインタラクティブな地図作成 3.1 ライブラリ読み込み 3.2 データ準備 3.3 ポップアップの文字作成 3.4 マーカーリスト 3.5 地図にプロットする 3.6 データ一覧 3.7 マーカーリスト", " Chapter: 3 緯度経度からちょっとインタラクティブな地図作成 参考にした記事 というかほぼこれ https://rpubs.com/kazutan/jssp2015_leaflet 3.1 ライブラリ読み込み library(tidyverse) library(here) library(DT) # 表作成用 library(ggmap) # 住所・緯度経度対応用 library(leaflet) # プロット用 library(stringi) # 全角から半角変換 3.2 データ準備 緯度経度取得後の想定データ # 東京ドーム 日本、112-0004 東京都文京区後楽１丁目３６１ 35.7056396 139.7518913 # 福島聖天通商店街 日本、553-0003 大阪府大阪市福島区福島７丁目７１２ 34.6976052 135.4846712 # 銀座通り商店街 日本、489-0043 愛知県瀬戸市朝日町 35.2266746 137.100508 df &lt;- tribble( ~id, ~lat, ~lon, ~address, ~group, ~name, 1, 35.7056396, 139.7518913,&quot;112-0004 東京都文京区後楽１丁目３６１&quot;, &quot;スポーツ&quot;, &quot;東京ドーム&quot;, 2, 34.6976052, 135.4846712,&quot;112-0004 東京都文京区後楽１丁目３６１&quot;, &quot;商店街A&quot; ,&quot;福島聖天通商店街&quot;, 3, 35.2266746, 137.100508,&quot;112-0004 東京都文京区後楽１丁目３６１&quot;, &quot;商店街B&quot;, &quot;銀座通り商店街&quot; ) # https://www.pediatricsurgery.site/entry/2017/10/12/105242 df &lt;- df %&gt;% mutate(address = stri_trans_nfkc(address)) # 住所の全角を半角に変換 df ## # A tibble: 3 x 6 ## id lat lon address group name ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1 35.7 140. 112-0004 東京都文京区後楽1丁目3-61 スポーツ 東京ドーム ## 2 2 34.7 135. 112-0004 東京都文京区後楽1丁目3-61 商店街A 福島聖天通商店街 ## 3 3 35.2 137. 112-0004 東京都文京区後楽1丁目3-61 商店街B 銀座通り商店街 3.3 ポップアップの文字作成 df &lt;- df %&gt;% mutate(popup = paste(name, group, address, sep=&quot;&lt;br/&gt;&quot;)) df ## # A tibble: 3 x 7 ## id lat lon address group name popup ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1 35.7 140. 112-0004 東京都文京区後楽1丁目3~ スポーツ~ 東京ドーム 東京ドーム&lt;br/&gt;スポーツ&lt;br/&gt;112-0004 東京都文京区後楽1丁~ ## 2 2 34.7 135. 112-0004 東京都文京区後楽1丁目3~ 商店街A 福島聖天通商店街~ 福島聖天通商店街&lt;br/&gt;商店街A&lt;br/&gt;112-0004 東京都文京区後~ ## 3 3 35.2 137. 112-0004 東京都文京区後楽1丁目3~ 商店街B 銀座通り商店街~ 銀座通り商店街&lt;br/&gt;商店街B&lt;br/&gt;112-0004 東京都文京区後楽~ 3.4 マーカーリスト icon_df &lt;- tibble(group = df$group, icon = paste0(here(&quot;picture/icon/&quot;), &quot;/&quot;,dir(here(&quot;picture/icon/&quot;))[1:3])) icon_df ## # A tibble: 3 x 2 ## group icon ## &lt;chr&gt; &lt;chr&gt; ## 1 スポーツ C:/Users/AkiyamaHiroki/Documents/Master/my_trivial/picture/icon/marker-icon-2x-black.png ## 2 商店街A C:/Users/AkiyamaHiroki/Documents/Master/my_trivial/picture/icon/marker-icon-2x-blue.png ## 3 商店街B C:/Users/AkiyamaHiroki/Documents/Master/my_trivial/picture/icon/marker-icon-2x-gold.png 3.5 地図にプロットする # iconの高さと幅 w &lt;- 20 h &lt;- 30 geo &lt;- df %&gt;% leaflet() %&gt;% addTiles() for (gru in df$group){ icon_list &lt;- icons(iconUrl = icon_df %&gt;% filter(group == gru) %&gt;% pull(icon), iconWidth = w, iconHeight = h, iconAnchorX = w/2, iconAnchorY = h) geo &lt;- geo %&gt;% addMarkers(lng = ~lon, lat = ~lat, popup = ~popup, group = gru, icon = icon_list, data = dplyr::filter(.data = df, group == gru)) %&gt;% addLayersControl(overlayGroups = df$group, options = layersControlOptions(collapsed = FALSE)) } geo 3.6 データ一覧 # 一覧表示 DT::datatable(dplyr::select(df,name:group),options = list(searchHighlight = TRUE), filter = &#39;top&#39;) 3.7 マーカーリスト icon_df &lt;- tibble(group = unique(df$group), icon = paste0(here(&quot;picture/icon/&quot;), &quot;/&quot;,dir(here(&quot;picture/icon/&quot;))[1:3])) icon_df ## # A tibble: 3 x 2 ## group icon ## &lt;chr&gt; &lt;chr&gt; ## 1 スポーツ C:/Users/AkiyamaHiroki/Documents/Master/my_trivial/picture/icon/marker-icon-2x-black.png ## 2 商店街A C:/Users/AkiyamaHiroki/Documents/Master/my_trivial/picture/icon/marker-icon-2x-blue.png ## 3 商店街B C:/Users/AkiyamaHiroki/Documents/Master/my_trivial/picture/icon/marker-icon-2x-gold.png "],["04_md-to-pdf.html", "Chapter: 4 pandocでmarkdownから日本語pdf出力 in vscode 4.1 目次 4.2 はじめに 4.3 目的 4.4 方法 4.5 サンプルmd 4.6 追記", " Chapter: 4 pandocでmarkdownから日本語pdf出力 in vscode 4.1 目次 はじめに 目的 方法 サンプルmd 4.2 はじめに 対象読者は、次の3つを満たしている人を想定しています。 vscodeがインストール済み Rstudioがインストール済み markdownを書いたことがある こんな感じで編集して、 こんな感じの.mdから こんな感じのpdfが出せるようになります 4.3 目的 vscodeでmarkdownを快適に編集して、日本語pdfを出力すること。 vscodeでmarkdownを編集される方は多いと思います。 なぜなら、markdownのプレビューを簡単に表示できるからです。 しかし、日本語pdfの出力がうまくいかなかったり、数式の出力ができなかったりする問題がよくあります。 その問題を解消するために、pandocを使用します。 4.4 方法 次の6つの手順を踏んで目的を達成します。 Rstudioのpandocにpathを通す vscodeの拡張機能をいろいろ追加する 簡易版TeX環境を作る ipaexフォントをインストールする front matter yamlを書く 出力のコマンド 4.4.1 Rstudioのpandocにpathを通す ココがこの記事でのキモです。 本来ならばpandocをインストールするところから始まりますが、ここではRstudioに組み込まれているpandocを使用することでインストール作業をスキップします。 Rstudioのpandocへのpathは、自分で設定する必要があります。Rstudioのpandocは、以下のようにbinの下にあります。 ~環境依存/Rstudio/bin/pandoc pathが通ったかどうかの確認として、プロンプトで次のコマンドを入力してください。 pandoc --version 以下のようにpandocのバージョンが出力されたら、pathの設定は完了です。 pandoc 2.7.2 Compiled with pandoc-types 1.17.5.4, texmath 0.11.2.2, skylighting 0.7.7 Default user data directory: C:\\Users\\AkiyamaHiroki\\AppData\\Roaming\\pandoc Copyright (C) 2006-2019 John MacFarlane Web: http://pandoc.org This is free software; see the source for copying conditions. There is no warranty, not even for merchantability or fitness for a particular purpose. 4.4.2 vscodeの拡張をいろいろ追加していく vscodeで拡張を追加する方法と、追加するいくつかの拡張について説明します。CUIで追加することもできますが、ここではGUIを使って拡張を追加します。 拡張機能リスト 拡張機能 必須/補助 内容 vscode-pandoc 必須 markdownをpandocでレンダリングするのに必要 Pandoc Markdown Preview 必須 shift + ctrl + rで、フロントマターyamlを含めたプレビューが表示できる Markdown All in One 補助 markdownの書式サポート、ほぼ必須(公式link) Markdown+Math 補助 数式のサポートいろいろ(こちらも公式linkで) 拡張機能を追加する方法 vscodeの左端っこにある、テトリスみたいなアイコンを押します。アイコンをクリックしたら、検索欄(Search Extensions in …)で追加したい拡張機能を検索します。 まずは「vscode-pandoc」と検索してみましょう。検索したら、vscode-pandoc をクリックします(私はバージョン0.0.8の方を使用しています)。あとはinstallボタンをクリックして少し待てば、インストール完了です。 拡張機能のインストールの仕方を説明しました。vscode-pandocの他にも、Pandoc Markdown Previewという拡張を必須として挙げています。先ほどと同様にインストールしましょう。 今インストールした2つの拡張以外にも便利な拡張機能がたくさんあるので、是非いろいろ試してみてください。 そして便利そうなやつは共有してください！ 4.4.3 簡易版TeX環境を作る TeX環境がすでに構築済みである方は手順4へ進んでください。 なぜTeX？と思われる方もいるかもしれません。 ここでTeXが必要な理由は、次のような理由からです。pandoc markdownをpdfに変換するときには、markdown  TeX  pdfという変換を行っています。したがって、TeXの環境が必要になるという訳です。 でも、TeXliveのインストールには労力がかかるのでやりません（私もTeXLiveはインストールしていません）。ではどうするかというとTinyTeXというものを使います。 TinyTeXとは、Rユーザー向けに作成された簡易TeX環境構築パッケージです。詳細はこちら（https://yihui.org/tinytex/）を参照ください。Rユーザー向けではありますが、vscodeでも十分に使えています（所感）。 ではTinyTeXをインストールしましょう。以下の2行のコマンドをRで実行するだけです。少々時間がかかると思います。コーヒーでも飲んで休憩して待ちましょう。 install.packages(&#39;tinytex&#39;) tinytex::install_tinytex() 4.4.4 ipaexフォントをインストールする ここでは日本語pdfの作成に必要なフォントをインストールします。 もちろんipaexフォント以外でもpdfの作成はできますが、少々込み入った話になってくるので今回はipaexフォントを使用します。 こちらのlink(https://ipafont.ipa.go.jp/old/ )よりipaexフォントをダウンロードして、PCにインストールします。 フォントインストールの手順はOSに依存します。 4.4.5 YAML front matter さて、ここが少しだけ込み入った話になります。 pandoc markdown（pandocを使うmarkdown）では、yamlフロントマターというのをmarkdownの先頭に記述します。 3つのハイフン—で上下を囲ったやつです。 たとえばpandocでmarkdownからpdf出力するときはこんな感じのyamlフロントマターを書きます。 --- title: &quot;pandocでmarkdownから日本語pdf出力 in vscode&quot; subtitle: &quot;&quot; author: &quot;Akiyama Hiroki&quot; date: &quot;yyyy-mm-dd&quot; geometry: &quot;left=3cm,right=3cm,top=2cm,bottom=2cm&quot; output: pdf_document: latex_engine: xelatex header-includes: - \\usepackage{xltxtra} # 日本語pdf用 - \\usepackage{zxjatype} # 日本語pdf用 - \\usepackage[ipaex]{zxjafont} # フォント指定 --- 引数 意味 title タイトル subtitle サブタイトル author 著者 date 日付 geometry 文書の余白 output 出力形式 header-includes以下 TeXパッケージ指定 これらのyaml内容は。大体どの文書にも共通して記述するものになっています。 header-includes以下に関しては、今回の日本語pdf作成用になっています。この他にもyamlフロントマターへの記述で設定できることはとてもたくさんありますが、それらはまた今度紹介します。たぶん。 vscodeの便利な点として、pdfやhtml出力をする際のpandocの引数を、設定に保存しておくことができる点があります。 「ctrl + ,」で設定画面を開きます。pandocと検索すると、次のような画面が出てきます。 ここのPdf Opt Stringに、 --pdf-engine xelatex -V geometry:margin=1in などと記述しておくことで、レンダリングする際のpandocの引数を保存しておくことができます。 こうすると、yamlの該当部分は省略して書くことができます。 4.4.6 出力のコマンド 準備は整いました。「ctrl + k」を押した後に、「p」を押して、pdfを選択すればpdf出力が完了します！ 4.5 サンプルmd ここに04_sample.mdを置きました。中身に書いてあることは本記事とほぼ同じものです。これをvscodeで開き、ここまで説明してきた準備を終えていれば、「ctrl + k」を押した後に「p」を押して、pdf出力ができるはずです。 (数式もTeXで書けます) \\[ f(x)={\\displaystyle\\sum_{k=0}^{\\infty}}f^{(k)}(0)\\dfrac{x^k}{k!}\\\\=f(0)+f&#39;(0)x+\\dfrac{f”(0)}{2!}x^2+\\dfrac{f^{(3)}(0)}{3!}x^3\\cdots \\] enjoy! 4.6 追記 現状だと、プレビューまではできるけど、出力はうまくいかない Rstudioで一度knitすることで、tex変換に必要なパッケージをインストールしてくれる tlmgr install ipaexをする必要あり tinytex::tlmgr_install(“ipaex”) "],["05_mystery.html", "Chapter: 5 slackの謎 5.1 投稿数激増！バトルドォーム！ 5.2 バトルドォーム！の差分 5.3 超！エキサイティン！！", " Chapter: 5 slackの謎 library(tidyverse) library(here) library(plotly) d &lt;- read_csv(here(&quot;data/slack0924.csv&quot;)) glimpse(d) ## Rows: 550 ## Columns: 21 ## $ 日付 &lt;date&gt; 2019-03-22, 2019-03-23, 2019-03-24, 2019-03-25,... ## $ メンバー数合計 &lt;dbl&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 6, 9,... ## $ 通常メンバー &lt;dbl&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 6, 9... ## $ ゲスト &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0... ## $ 日間アクティブメンバー数 &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 8, 7, 1... ## $ `メッセージを投稿したメンバー数の推移(日別)` &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 4, 3, 2, 5, 3, ... ## $ 週間アクティブメンバー数 &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 9, 12, ... ## $ `メッセージを投稿したメンバー数の推移(週別)` &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 5, 7, 7, 9, 9, ... ## $ パブリックチャンネルのメッセージ &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 4, 5, 4, 7,... ## $ プライベートチャンネルのメッセージ &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ... ## $ 共有チャンネルへの投稿メッセージ数 &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ... ## $ ダイレクトメッセージでの投稿メッセージ数 &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 3, 2, 0, 5, 17,... ## $ `メッセージの割合、パブリックチャンネル` &lt;dbl&gt; 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0... ## $ `メッセージの割合、プライベートチャンネル` &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ... ## $ `メッセージの割合、DM` &lt;dbl&gt; 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000,... ## $ `表示回数の割合、パブリックチャンネル` &lt;dbl&gt; 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, ... ## $ `表示回数の割合、プライベートチャンネル` &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,... ## $ `表示回数の割合、DM` &lt;dbl&gt; 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000... ## $ 名前 &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ... ## $ `パブリックチャンネル、1つのワークスペース` &lt;dbl&gt; 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, ... ## $ 投稿されたメッセージ数 &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 21, 42, 6... long_d &lt;- d %&gt;% select(日付, メンバー数合計, 投稿されたメッセージ数) %&gt;% pivot_longer(-日付) p &lt;- long_d %&gt;% ggplot(aes(x = 日付, y = value)) + geom_line() + facet_wrap(facets = vars(name), ncol = 1, scales = &quot;free_y&quot;) + labs(title = &quot;バトルドォーム！ red：誕生、blue:お引越し&quot;, x = &quot;月&quot;, y = &quot;&quot;) + geom_vline(xintercept = as.Date(&quot;2020-02-12&quot;), color = &quot;red&quot;, size = 0.2) + geom_vline(xintercept = as.Date(&quot;2020-04-07&quot;), color = &quot;blue&quot;, size = 0.2) + scale_x_date(date_breaks = &quot;1 month&quot;, date_labels = &quot;%b&quot;) 5.1 投稿数激増！バトルドォーム！ ggplotly(p, dynamicTicks = T) p long_d &lt;- d %&gt;% select(日付, 投稿されたメッセージ数) long_d &lt;- long_d %&gt;% mutate(lag1 = 投稿されたメッセージ数 - lag(投稿されたメッセージ数)) p &lt;- long_d %&gt;% ggplot(aes(x = 日付, y = lag1)) + geom_line() + labs(title = &quot;前日の投稿メッセージ数からの増減 red：誕生、blue:お引越し&quot;, x = &quot;月&quot;, y = &quot;&quot;) + geom_vline(xintercept = as.Date(&quot;2020-02-12&quot;), color = &quot;red&quot;, size = 0.2) + geom_vline(xintercept = as.Date(&quot;2020-04-07&quot;), color = &quot;blue&quot;, size = 0.2) + scale_x_date(date_breaks = &quot;1 month&quot;, date_labels = &quot;%b&quot;) 5.2 バトルドォーム！の差分 ggplotly(p, dynamicTicks = T) p ## Warning: Removed 1 row(s) containing missing values (geom_path). d2 &lt;- d %&gt;% select(日付, 日間アクティブメンバー数, パブリックチャンネルのメッセージ, プライベートチャンネルのメッセージ, ダイレクトメッセージでの投稿メッセージ数) p2 &lt;- d2 %&gt;% pivot_longer(-日付) %&gt;% ggplot(aes(x = 日付, y = value)) + geom_line() + facet_wrap(facets = vars(name), ncol = 1, scales = &quot;free_y&quot;) + labs(title = &quot;超！エキサイティン！！ red：誕生、blue:お引越し&quot;, x = &quot;月&quot;, y = &quot;&quot;) + geom_vline(xintercept = as.Date(&quot;2020-02-12&quot;), color = &quot;red&quot;, size = 0.2) + geom_vline(xintercept = as.Date(&quot;2020-04-07&quot;), color = &quot;blue&quot;, size = 0.2) + scale_x_date(date_breaks = &quot;1 month&quot;, date_labels = &quot;%b&quot;) 5.3 超！エキサイティン！！ plotly::ggplotly(p2, dynamicTicks = TRUE) p2 "],["06_NBA_cluster.html", "Chapter: 6 NBAのスタッツデータでクラスタリング 6.1 前処理 6.2 可視化 6.3 kmeansでクラスタリング 6.4 雑感", " Chapter: 6 NBAのスタッツデータでクラスタリング ここ （https://www.kaggle.com/drgilermo/nba-players-stats） に公開されているNBA選手のスタッツや身長体重などのデータを用いて、クラスタリングをおこなう。 kmeansを使用し、クラスタ数は2,3,5の3パターンを試した。 バスケのポジションごとにクラスタとなればいいなと期待していた。 しかし結果としては、スタメンやスター選手、控えの選手、あまり出場機会がない選手というようなクラスタに別れた。 以下にコードと結果を示す。 6.1 前処理 6.1.1 ライブラリとデータ読み込み library(tidyverse) library(dplyr) library(ggplot2) library(purrr) library(tibble) library(tidyr) library(tidymodels) library(factoextra) library(NbClust) library(patchwork) library(naniar) # vis_miss library(ggrepel) library(here) read_csvの自動識別だと微妙なので、読み込むカラム型を事前に決めておく。 set_coltypes &lt;- cols( .default = col_double(), Year = col_double(), Player = col_character(), Pos = col_character(), Age = col_double(), Tm = col_character(), G = col_double(), GS = col_double(), MP = col_double(), PER = col_double(), `TS%` = col_double(), `3PAr` = col_double(), FTr = col_double(), `ORB%` = col_double(), `DRB%` = col_double(), `TRB%` = col_double(), `AST%` = col_double(), `STL%` = col_double(), `BLK%` = col_double(), `TOV%` = col_double(), `USG%` = col_double(), blanl = col_skip(), OWS = col_double(), DWS = col_double(), WS = col_double(), `WS/48` = col_double(), blank2 = col_skip(), OBPM = col_double(), DBPM = col_double(), BPM = col_double(), VORP = col_double(), FG = col_double(), FGA = col_double(), `FG%` = col_double(), `3P` = col_double(), `3PA` = col_double(), `3P%` = col_double(), `2P` = col_double(), `2PA` = col_double(), `2P%` = col_double(), `eFG%` = col_double(), FT = col_double(), FTA = col_double(), `FT%` = col_double(), ORB = col_double(), DRB = col_double(), TRB = col_double(), AST = col_double(), STL = col_double(), BLK = col_double(), TOV = col_double(), PF = col_double(), PTS = col_double() ) Seasons_Stats.csvを読み込む。Players.csvを読み込む。Playersから身長と体重のカラムを、Seasons_Statsにジョインさせる。ジョインしたものをdataとする。 players &lt;- read_csv(here(&quot;data/Players.csv&quot;)) seasons_stats &lt;- read_csv(here(&quot;data/Seasons_Stats.csv&quot;), col_types = set_coltypes) data &lt;- players %&gt;% select(Player, height, weight) %&gt;% right_join(seasons_stats, by = &quot;Player&quot;) 6.1.2 データの整理 データを2000年以降に絞る 古いデータはスタッツが取れていなくて欠損が多いため 選手の名前で、最新のデータから順にユニークをとる X1 はインデックスなので消去する 最新の選手データに絞ったので、Yearはもう不要だから消去 data_2000_uniquename &lt;- data %&gt;% filter(Year &gt;= 2000) %&gt;% arrange(desc(Year)) %&gt;% distinct(Player, .keep_all = TRUE) %&gt;% select(-X1, -Year) 6.1.3 各ポジションの選手数 data_2000_uniquename %&gt;% group_by(Pos) %&gt;% count # A tibble: 14 x 2 # Groups: Pos [14] Pos n &lt;chr&gt; &lt;int&gt; 1 C 362 2 C-PF 4 3 C-SF 1 4 PF 318 5 PF-C 3 6 PF-SF 1 7 PG 325 8 PG-SG 4 9 SF 333 10 SF-PF 5 11 SF-SG 3 12 SG 322 13 SG-PG 5 14 SG-SF 4 6.1.4 ５つのポジションにする C-PFや、PG-SGなどの2ポジション登録されているものは数が少ないので消去して、5つのポジション(PG, SG, SF, PF, C)のみにする。 data_2000_uniquename_5pos &lt;- data_2000_uniquename %&gt;% filter(Pos %in% c(&quot;PG&quot;, &quot;SG&quot;, &quot;SF&quot;, &quot;PF&quot;, &quot;C&quot;)) %&gt;% mutate(Pos = fct_relevel(Pos ,&quot;PG&quot;, &quot;SG&quot;, &quot;SF&quot;, &quot;PF&quot;, &quot;C&quot;)) 6.1.5 欠損の可視化 data_2000_uniquename_5pos %&gt;% vis_miss() 6.1.6 欠損の除去 3P%とFT%の欠損は、3PとFTのアテンプトがないことによるものである（たぶん）。 3Pと3PAの値は入っているため、3P%は情報量として特に意味がないので使用しないことにする。 同様にしてFT%も使用しないこととする。 その他に欠損が存在しているレコードは数が少ないので、それらのレコードは除いて分析をおこなうことにする。 data_2000_uniquename_5pos_clean &lt;- data_2000_uniquename_5pos %&gt;% select(-`3P%`, -`FT%`) %&gt;% drop_na() data_2000_uniquename_5pos_clean %&gt;% vis_miss() 欠損値がなくなった綺麗なデータができあがった。 6.1.7 チームの略称を整理する 現在のNBAは東西合わせて30チームある。今扱っているデータには、チームの略称が変わっているものなどが存在するので、それを統一する。 CHH, CHOは、現在のCHAなので、CHAに統一する。 NJNはニュージャージーネッツ、現在のブルックリンネッツなので、BRKに統一する。 NOH, NOKは、現在のNOPだから統一する。 TOTは、シーズン途中で移籍した選手に関して、移籍前と後の成績を足し合わせたもの。だから、今回はTOTは外す。 VANはバンクーバーグリズリーズ、現在のメンフィスグリズーズだから、MEMに統一する。 SEAはOKCに統一する。 data_2000_uniquename_5pos_clean &lt;- data_2000_uniquename_5pos_clean %&gt;% mutate(Tm_30 = case_when( Tm %in% c(&quot;CHH&quot;, &quot;CHO&quot;) ~ &quot;CHA&quot;, Tm == &quot;NJN&quot; ~ &quot;BRK&quot;, Tm %in% c(&quot;NOH&quot;, &quot;NOK&quot;) ~ &quot;NOP&quot;, Tm == &quot;VAN&quot; ~ &quot;MEM&quot;, Tm == &quot;SEA&quot; ~ &quot;OKC&quot;, TRUE ~ Tm) # case_whenを使うときはTRUE のケースを忘れないように注意する ) %&gt;% filter(Tm != &quot;TOT&quot;) 6.2 可視化 6.2.1 クラスタリングに使用するデータ 6.2.2 PCAしてみる rec_preped &lt;- data_2000_uniquename_5pos_clean %&gt;% recipe() %&gt;% step_center(all_numeric()) %&gt;% step_scale(all_numeric()) %&gt;% step_pca(all_numeric(), threshold = .80) %&gt;% prep() t &lt;- rec_preped$steps[[3]]$res %&gt;% summary() t$importance %&gt;% as_tibble() %&gt;% slice(3) %&gt;% pivot_longer(cols = everything()) %&gt;% mutate(name = as_factor(name)) %&gt;% ggplot(aes(x = name, y = value)) + geom_point() + theme(axis.text.x = element_text(angle = 45, hjust = 1)) + theme(text = element_text(family = &quot;Japan1GothicBBB&quot;)) + labs(x = &quot;&quot;, y = &quot;累積寄与率&quot;, title = &quot;主成分分析の累積寄与率&quot;) + ylim(0,1) data_pca80 &lt;- rec_preped %&gt;% juice() 6.2.3 PCAの２軸でポジション別プロット p_pca &lt;- data_pca80 %&gt;% ggplot(aes(PC1, PC2, color = Pos)) + geom_point() + labs(title = &quot;PCAの2軸で でポジション別&quot;) p_pca 6.2.4 チーム別ポジション別でPCA２軸 p_pca_facet_team &lt;- data_pca80 %&gt;% ggplot(aes(PC1, PC2, color = Pos)) + geom_point() + facet_wrap(vars(Tm_30)) p_pca_facet_team 一部の選手のみラベルを表示させるために、ラベルのカラムを作成する。 data_pca80 &lt;- data_pca80 %&gt;% mutate(label = if_else(condition = (10 &lt;= PC1| 5 &lt;= PC2), true = as.character(Player), false = &quot;&quot; )) p_pca_facet_team_label &lt;- data_pca80 %&gt;% ggplot(aes(PC1, PC2, color = Pos, label = label)) + geom_point() + geom_text_repel() + facet_wrap(vars(Tm_30)) p_pca_facet_team_label 6.3 kmeansでクラスタリング 6.3.1 エルボー法とシルエット法でクラスタ数チェック # Elbow method p_elbow &lt;- data_2000_uniquename_5pos_clean %&gt;% select(where(is.numeric)) %&gt;% fviz_nbclust(kmeans, method = &quot;wss&quot;) + geom_vline(xintercept = 3, linetype = 2) + # add line for better visualisation labs(subtitle = &quot;Elbow method&quot;) # add subtitle p_silhouette &lt;- data_2000_uniquename_5pos_clean %&gt;% select(where(is.numeric)) %&gt;% fviz_nbclust(kmeans, method = &quot;silhouette&quot;) + labs(subtitle = &quot;Silhouette method&quot;) p_elbow | p_silhouette エルボーでは3、シルエットでは2がよさそう。 6.3.2 kmeans２と３と５ my_kmeans &lt;- function(data, centers, nstart = 50){ model &lt;- data %&gt;% select(where(is.numeric)) %&gt;% kmeans(centers = centers, nstart = nstart) cat(&quot;クラスタ数&quot;, centers ,&quot;, クラスタ間分散/全体分散 * 100 = &quot;, 100 * model$betweenss / model$totss, &quot;\\n&quot;) return(as.character(model$cluster)) } set.seed(7777) data_2000_uniquename_5pos_clean$kmeans2 &lt;- my_kmeans(data_2000_uniquename_5pos_clean, centers = 2, nstart = 50) クラスタ数 2 , クラスタ間分散/全体分散 * 100 = 69.22037 set.seed(7777) data_2000_uniquename_5pos_clean$kmeans3 &lt;- my_kmeans(data_2000_uniquename_5pos_clean, centers = 3, nstart = 50) クラスタ数 3 , クラスタ間分散/全体分散 * 100 = 83.51925 set.seed(7777) data_2000_uniquename_5pos_clean$kmeans5 &lt;- my_kmeans(data_2000_uniquename_5pos_clean, centers = 5, nstart = 50) クラスタ数 5 , クラスタ間分散/全体分散 * 100 = 91.14289 6.3.3 結果をPCAの2軸で可視化してみる。 rec_preped &lt;- data_2000_uniquename_5pos_clean %&gt;% recipe() %&gt;% step_center(all_numeric()) %&gt;% step_scale(all_numeric()) %&gt;% step_pca(all_numeric(), threshold = .80) %&gt;% prep() data_pca80 &lt;- rec_preped %&gt;% juice() cluster_2 &lt;- data_pca80 %&gt;% ggplot(aes(PC1, PC2, color = kmeans2)) + geom_point() + labs(title = &quot;PCAの2軸で 2クラスタ&quot;) + theme(legend.position = &quot;bottom&quot;) cluster_3 &lt;- data_pca80 %&gt;% ggplot(aes(PC1, PC2, color = kmeans3)) + geom_point() + labs(title = &quot;PCAの2軸で 3クラスタ&quot;) + theme(legend.position = &quot;bottom&quot;) cluster_5 &lt;- data_pca80 %&gt;% ggplot(aes(PC1, PC2, color = kmeans5)) + geom_point() + labs(title = &quot;PCAの2軸で 5クラスタ&quot;) + theme(legend.position = &quot;bottom&quot;) (p_pca | cluster_2) / (cluster_3 | cluster_5) お世辞にもポジションでクラスタに分かれたようには見えへん！！！！ 近年のNBAでは、どのポジションでもドリブル・シュート・アシストなどが高いレベルでできることが求められている。 改めて考えると、身長体重やスタッツのデータがポジションごとでクラスタになるのは、確かにありえないか、とも思う。 とりあえず固まった、３クラスタで見ていく。 6.3.4 チーム別kmeansプロット インタラクティブなプロットになってます。 p_pca_facet_team_kmeans3 &lt;- data_pca80 %&gt;% ggplot(aes(PC1, PC2, color = kmeans3, label = Player)) + geom_point() + facet_wrap(vars(Tm_30)) # p_pca_facet_team_kmeans3 plotly::ggplotly(p_pca_facet_team_kmeans3, dynamicTicks = T) 6.3.5 選手名つき インタラクティブプロットを見る感じ、どうやら緑のクラスタは、スタメンやスター級の選手が固まっているらしい。 一部の選手のみラベルを表示させるために、ラベルのカラムを作成する。PC1が10以上の選手のみラベルをつける。 data_pca80 &lt;- data_pca80 %&gt;% mutate(label = if_else(condition = (10 &lt;= PC1), true = as.character(Player), false = &quot;&quot; )) p_pca_facet_team_label_kmeans3 &lt;- data_pca80 %&gt;% ggplot(aes(PC1, PC2, color = kmeans3, label = label)) + geom_point() + geom_text_repel() + facet_wrap(vars(Tm_30)) p_pca_facet_team_label_kmeans3 やはりスター選手やスタメンの選手がほぼすべてである。 6.3.6 スタメンかどうかでわける 半分以上の試合でスタメンの選手のみで、クラスタの集計をしてみる。 data_pca80 %&gt;% left_join(data_2000_uniquename_5pos_clean %&gt;% select(Player, GS), by = &quot;Player&quot;) %&gt;% filter(GS &gt;= 41) %&gt;% group_by(kmeans3) %&gt;% count() # A tibble: 2 x 2 # Groups: kmeans3 [2] kmeans3 n &lt;fct&gt; &lt;int&gt; 1 1 39 2 2 120 逆に、半分の試合でスタメンでないクラスタを集計するとこうなる。 data_pca80 %&gt;% left_join(data_2000_uniquename_5pos_clean %&gt;% select(Player, GS), by = &quot;Player&quot;) %&gt;% filter(GS &lt;= 41) %&gt;% group_by(kmeans3) %&gt;% count() # A tibble: 3 x 2 # Groups: kmeans3 [3] kmeans3 n &lt;fct&gt; &lt;int&gt; 1 1 299 2 2 38 3 3 926 6.4 雑感 ポジションクラスタという期待していた結果にはならなかったが、これはこれで面白い結果になったと思う。 クラスタリングにかけるデータを取捨選択するとかなんとかすれば（たとえば身長・体重と何かだけとか）、ポジションクラスタもできるかもしれない。 他にも、年代別とかでもっと分析ができそうだなと感じた。時間があればやる！！！！ "],["07_cross_tally.html", "Chapter: 7 Rでクロス集計（janitor） 7.1 janitorパッケージ 7.2 データの準備 7.3 cutカラムの度数表 7.4 欠損がある場合 7.5 度数表のtotal値 7.6 度数表の％表記 7.7 クロス集計 7.8 クロス集計の装飾 7.9 関数化 7.10 可視化", " Chapter: 7 Rでクロス集計（janitor） janitorパッケージを使うと、Rでのクロス集計がかなり捗る。 クロス集計をする前に、まずは1つのデータでの度数表の作成や、その他便利な関数を紹介する。 その後に、クロス集計を行う。 最後に、クロス集計で出来たデータでの可視化も行ってみる。 本節のゴール （空白セルはNA） 7.1 janitorパッケージ knitr::opts_chunk$set(comment = &quot;&quot;) if (!require(&quot;janitor&quot;)) install.packages(&quot;janitor&quot;) if (!require(&quot;naniar&quot;)) install.packages(&quot;naniar&quot;) if (!require(&quot;DT&quot;)) install.packages(&quot;DT&quot;) library(janitor) library(naniar) library(tidyverse) 7.2 データの準備 Rに標準搭載されているdiamondsデータを使う。 今回はクロス集計をおこなうため、cut と colorのカラムを主に扱う。 data &lt;- diamonds %&gt;% as_tibble() data %&gt;% glimpse() Rows: 53,940 Columns: 10 $ carat &lt;dbl&gt; 0.23, 0.21, 0.23, 0.29, 0.31, 0.24, 0.24, 0.26, 0.22, 0.23, 0.30, 0.23, 0.22, 0.31,... $ cut &lt;ord&gt; Ideal, Premium, Good, Premium, Good, Very Good, Very Good, Very Good, Fair, Very Go... $ color &lt;ord&gt; E, E, E, I, J, J, I, H, E, H, J, J, F, J, E, E, I, J, J, J, I, E, H, J, J, G, I, J,... $ clarity &lt;ord&gt; SI2, SI1, VS1, VS2, SI2, VVS2, VVS1, SI1, VS2, VS1, SI1, VS1, SI1, SI2, SI2, I1, SI... $ depth &lt;dbl&gt; 61.5, 59.8, 56.9, 62.4, 63.3, 62.8, 62.3, 61.9, 65.1, 59.4, 64.0, 62.8, 60.4, 62.2,... $ table &lt;dbl&gt; 55, 61, 65, 58, 58, 57, 57, 55, 61, 61, 55, 56, 61, 54, 62, 58, 54, 54, 56, 59, 56,... $ price &lt;int&gt; 326, 326, 327, 334, 335, 336, 336, 337, 337, 338, 339, 340, 342, 344, 345, 345, 348... $ x &lt;dbl&gt; 3.95, 3.89, 4.05, 4.20, 4.34, 3.94, 3.95, 4.07, 3.87, 4.00, 4.25, 3.93, 3.88, 4.35,... $ y &lt;dbl&gt; 3.98, 3.84, 4.07, 4.23, 4.35, 3.96, 3.98, 4.11, 3.78, 4.05, 4.28, 3.90, 3.84, 4.37,... $ z &lt;dbl&gt; 2.43, 2.31, 2.31, 2.63, 2.75, 2.48, 2.47, 2.53, 2.49, 2.39, 2.73, 2.46, 2.33, 2.71,... 先頭100行だけを表示。 data %&gt;% head(100) %&gt;% DT::datatable() 欠損値は存在しない。 data %&gt;% vis_miss() 7.3 cutカラムの度数表 通常のやり方では、（１）table関数を使用して次のようにしたり、 table(data$cut) Fair Good Very Good Premium Ideal 1610 4906 12082 13791 21551 （２）count関数を使ったり data %&gt;% count(cut) # A tibble: 5 x 2 cut n &lt;ord&gt; &lt;int&gt; 1 Fair 1610 2 Good 4906 3 Very Good 12082 4 Premium 13791 5 Ideal 21551 （３）dplyrを使う方法などがある。 data %&gt;% group_by(cut) %&gt;% tally() # A tibble: 5 x 2 cut n &lt;ord&gt; &lt;int&gt; 1 Fair 1610 2 Good 4906 3 Very Good 12082 4 Premium 13791 5 Ideal 21551 janitorパッケージの関数を使うと、次のように書くことができる。 table関数の進化系という感じで、tabylという関数を使う。 data %&gt;% tabyl(cut) cut n percent Fair 1610 0.02984798 Good 4906 0.09095291 Very Good 12082 0.22398962 Premium 13791 0.25567297 Ideal 21551 0.39953652 見てわかると思うが、度数の横に割合も表示してくれるのが既に便利である。 なおtabylの出力結果のclassはtabyl(data.frame)となっているので、tibbleにして扱いやすくしておく。 data %&gt;% tabyl(cut) %&gt;% class [1] &quot;tabyl&quot; &quot;data.frame&quot; data %&gt;% tabyl(cut) %&gt;% as_tibble # A tibble: 5 x 3 cut n percent &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Fair 1610 0.0298 2 Good 4906 0.0910 3 Very Good 12082 0.224 4 Premium 13791 0.256 5 Ideal 21551 0.400 dplyrで割合の計算もしようとすると、コードが少し長くなる。 data %&gt;% count(cut) %&gt;% mutate(percent = n/sum(n)) # A tibble: 5 x 3 cut n percent &lt;ord&gt; &lt;int&gt; &lt;dbl&gt; 1 Fair 1610 0.0298 2 Good 4906 0.0910 3 Very Good 12082 0.224 4 Premium 13791 0.256 5 Ideal 21551 0.400 7.4 欠損がある場合 最初に確認したが、もとのdiamondsデータには欠損が含まれていないので、人工的に欠損値を仕込む。 N &lt;- nrow(data) set.seed(334) n &lt;- sample(1:N, 10000) data_include_na &lt;- data %&gt;% mutate(index = row_number()) %&gt;% mutate(cut = if_else(index %in% n, as.character(NA), as.character(cut))) data_include_na %&gt;% vis_miss() 集計値にNAがある場合、valid_percent（欠損を除いた割合）カラムが自動的に追加される。 data_include_na %&gt;% tabyl(cut) %&gt;% as_tibble() # A tibble: 6 x 4 cut n percent valid_percent &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Fair 1295 0.0240 0.0295 2 Good 3957 0.0734 0.0901 3 Ideal 17594 0.326 0.400 4 Premium 11317 0.210 0.258 5 Very Good 9777 0.181 0.223 6 &lt;NA&gt; 10000 0.185 NA 7.5 度数表のtotal値 度数表にtotal値を追加するにはadorn_totalsという関数を使用する。 adornは「装飾する」という意味らしい。 最後の行にTotal値が入る。 data_include_na %&gt;% tabyl(cut) %&gt;% adorn_totals() %&gt;% as_tibble() # A tibble: 7 x 4 cut n percent valid_percent &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Fair 1295 0.0240 0.0295 2 Good 3957 0.0734 0.0901 3 Ideal 17594 0.326 0.400 4 Premium 11317 0.210 0.258 5 Very Good 9777 0.181 0.223 6 &lt;NA&gt; 10000 0.185 NA 7 Total 53940 1 1 7.6 度数表の％表記 度数表を作成したあとにそのデータで分析を進めないのであれば、割合を％表記にすると少し表が見やすくなる。 adorn_pct_formatting関数を使う。 digits で桁数を指定する。 affix_singをFALSEにすれば％表記を消すこともできる。 data_include_na %&gt;% tabyl(cut) %&gt;% adorn_totals() %&gt;% adorn_pct_formatting(digits = 2, affix_sign = TRUE) %&gt;% as_tibble() # A tibble: 7 x 4 cut n percent valid_percent &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; 1 Fair 1295 2.40% 2.95% 2 Good 3957 7.34% 9.01% 3 Ideal 17594 32.62% 40.04% 4 Premium 11317 20.98% 25.76% 5 Very Good 9777 18.13% 22.25% 6 &lt;NA&gt; 10000 18.54% - 7 Total 53940 100.00% 100.00% 7.7 クロス集計 いよいよクロス集計をしてみる。 7.7.1 通常のやり方 通常のやり方では、table関数を使用して次のようにする。 度数表 table(data_include_na$cut, data_include_na$color) D E F G H I J Fair 136 179 243 248 248 142 99 Good 555 756 715 689 572 425 245 Ideal 2284 3219 3124 4000 2518 1711 738 Premium 1302 1919 1920 2386 1933 1181 676 Very Good 1252 1936 1755 1857 1480 968 529 割合 prop.table(table(data_include_na$cut, data_include_na$color)) D E F G H I J Fair 0.003095130 0.004073737 0.005530269 0.005644060 0.005644060 0.003231680 0.002253072 Good 0.012630860 0.017205280 0.016272189 0.015680473 0.013017751 0.009672280 0.005575785 Ideal 0.051979973 0.073258990 0.071096950 0.091033227 0.057305416 0.038939463 0.016795630 Premium 0.029631315 0.043673191 0.043695949 0.054301320 0.043991807 0.026877560 0.015384615 Very Good 0.028493400 0.044060082 0.039940828 0.042262176 0.033682294 0.022030041 0.012039144 7.7.2 janitorのやり方 janitorパッケージのtabyl関数を使うと次のように書ける。 度数表 data_include_na %&gt;% tabyl(cut, color) %&gt;% as_tibble() # A tibble: 6 x 8 cut D E F G H I J &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Fair 136 179 243 248 248 142 99 2 Good 555 756 715 689 572 425 245 3 Ideal 2284 3219 3124 4000 2518 1711 738 4 Premium 1302 1919 1920 2386 1933 1181 676 5 Very Good 1252 1936 1755 1857 1480 968 529 6 &lt;NA&gt; 1246 1788 1785 2112 1553 995 521 割合 adorn_percentages関数を使用する。 denominatorは “all”, “col”, “row”の中から選ぶことができる。 同時確率を見たいか、行か列での条件つき確率をみたいかどうかで変える。 data_include_na %&gt;% tabyl(cut, color) %&gt;% adorn_percentages(denominator = &quot;all&quot;) %&gt;% as_tibble() # A tibble: 6 x 8 cut D E F G H I J &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Fair 0.00252 0.00332 0.00451 0.00460 0.00460 0.00263 0.00184 2 Good 0.0103 0.0140 0.0133 0.0128 0.0106 0.00788 0.00454 3 Ideal 0.0423 0.0597 0.0579 0.0742 0.0467 0.0317 0.0137 4 Premium 0.0241 0.0356 0.0356 0.0442 0.0358 0.0219 0.0125 5 Very Good 0.0232 0.0359 0.0325 0.0344 0.0274 0.0179 0.00981 6 &lt;NA&gt; 0.0231 0.0331 0.0331 0.0392 0.0288 0.0184 0.00966 data_include_na %&gt;% tabyl(cut, color) %&gt;% adorn_percentages(denominator = &quot;col&quot;) %&gt;% as_tibble() # A tibble: 6 x 8 cut D E F G H I J &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Fair 0.0201 0.0183 0.0255 0.0220 0.0299 0.0262 0.0353 2 Good 0.0819 0.0772 0.0749 0.0610 0.0689 0.0784 0.0873 3 Ideal 0.337 0.329 0.327 0.354 0.303 0.316 0.263 4 Premium 0.192 0.196 0.201 0.211 0.233 0.218 0.241 5 Very Good 0.185 0.198 0.184 0.164 0.178 0.179 0.188 6 &lt;NA&gt; 0.184 0.183 0.187 0.187 0.187 0.184 0.186 data_include_na %&gt;% tabyl(cut, color) %&gt;% adorn_percentages(denominator = &quot;row&quot;) %&gt;% as_tibble() # A tibble: 6 x 8 cut D E F G H I J &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Fair 0.105 0.138 0.188 0.192 0.192 0.110 0.0764 2 Good 0.140 0.191 0.181 0.174 0.145 0.107 0.0619 3 Ideal 0.130 0.183 0.178 0.227 0.143 0.0972 0.0419 4 Premium 0.115 0.170 0.170 0.211 0.171 0.104 0.0597 5 Very Good 0.128 0.198 0.180 0.190 0.151 0.0990 0.0541 6 &lt;NA&gt; 0.125 0.179 0.178 0.211 0.155 0.0995 0.0521 7.8 クロス集計の装飾 7.8.1 totalと％ 度数表と同様にして、Total値を付けたり、％表記をすることができる。 カラムごとに合計 data_include_na %&gt;% tabyl(cut, color) %&gt;% adorn_totals(where = c(&quot;row&quot;)) %&gt;% adorn_percentages(denominator = &quot;col&quot;) %&gt;% adorn_pct_formatting(digits = 2, affix_sign = TRUE) %&gt;% as_tibble() # A tibble: 7 x 8 cut D E F G H I J &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; 1 Fair 2.01% 1.83% 2.55% 2.20% 2.99% 2.62% 3.53% 2 Good 8.19% 7.72% 7.49% 6.10% 6.89% 7.84% 8.73% 3 Ideal 33.71% 32.86% 32.74% 35.42% 30.32% 31.56% 26.28% 4 Premium 19.22% 19.59% 20.12% 21.13% 23.28% 21.78% 24.07% 5 Very Good 18.48% 19.76% 18.39% 16.45% 17.82% 17.85% 18.84% 6 &lt;NA&gt; 18.39% 18.25% 18.71% 18.70% 18.70% 18.35% 18.55% 7 Total 100.00% 100.00% 100.00% 100.00% 100.00% 100.00% 100.00% 行ごとに合計 data_include_na %&gt;% tabyl(cut, color) %&gt;% adorn_totals(where = c(&quot;col&quot;)) %&gt;% adorn_percentages(denominator = &quot;row&quot;) %&gt;% adorn_pct_formatting(digits = 2, affix_sign = TRUE) %&gt;% as_tibble() # A tibble: 6 x 9 cut D E F G H I J Total &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; 1 Fair 10.50% 13.82% 18.76% 19.15% 19.15% 10.97% 7.64% 100.00% 2 Good 14.03% 19.11% 18.07% 17.41% 14.46% 10.74% 6.19% 100.00% 3 Ideal 12.98% 18.30% 17.76% 22.74% 14.31% 9.72% 4.19% 100.00% 4 Premium 11.50% 16.96% 16.97% 21.08% 17.08% 10.44% 5.97% 100.00% 5 Very Good 12.81% 19.80% 17.95% 18.99% 15.14% 9.90% 5.41% 100.00% 6 &lt;NA&gt; 12.46% 17.88% 17.85% 21.12% 15.53% 9.95% 5.21% 100.00% 全体で合計 data_include_na %&gt;% tabyl(cut, color) %&gt;% adorn_totals(where = c(&quot;col&quot;, &quot;row&quot;)) %&gt;% adorn_percentages(denominator = &quot;all&quot;) %&gt;% adorn_pct_formatting(digits = 2, affix_sign = TRUE) %&gt;% as_tibble() # A tibble: 7 x 9 cut D E F G H I J Total &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; 1 Fair 0.25% 0.33% 0.45% 0.46% 0.46% 0.26% 0.18% 2.40% 2 Good 1.03% 1.40% 1.33% 1.28% 1.06% 0.79% 0.45% 7.34% 3 Ideal 4.23% 5.97% 5.79% 7.42% 4.67% 3.17% 1.37% 32.62% 4 Premium 2.41% 3.56% 3.56% 4.42% 3.58% 2.19% 1.25% 20.98% 5 Very Good 2.32% 3.59% 3.25% 3.44% 2.74% 1.79% 0.98% 18.13% 6 &lt;NA&gt; 2.31% 3.31% 3.31% 3.92% 2.88% 1.84% 0.97% 18.54% 7 Total 12.56% 18.16% 17.69% 20.93% 15.39% 10.05% 5.21% 100.00% 7.8.2 集計値の名前を変更 adorn_titleという関数を使うと、何と何で集計を行っているかを一番左上のセルに追加できる。 data_include_na %&gt;% tabyl(cut, color) %&gt;% adorn_totals(where = c(&quot;row&quot;, &quot;col&quot;)) %&gt;% adorn_percentages(denominator = &quot;col&quot;) %&gt;% adorn_pct_formatting(digits = 2) %&gt;% adorn_title(placement = &quot;combined&quot;, col_name = &quot;color&quot;) %&gt;% as_tibble() # A tibble: 7 x 9 `cut/color` D E F G H I J Total &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; 1 Fair 2.01% 1.83% 2.55% 2.20% 2.99% 2.62% 3.53% 2.40% 2 Good 8.19% 7.72% 7.49% 6.10% 6.89% 7.84% 8.73% 7.34% 3 Ideal 33.71% 32.86% 32.74% 35.42% 30.32% 31.56% 26.28% 32.62% 4 Premium 19.22% 19.59% 20.12% 21.13% 23.28% 21.78% 24.07% 20.98% 5 Very Good 18.48% 19.76% 18.39% 16.45% 17.82% 17.85% 18.84% 18.13% 6 &lt;NA&gt; 18.39% 18.25% 18.71% 18.70% 18.70% 18.35% 18.55% 18.54% 7 Total 100.00% 100.00% 100.00% 100.00% 100.00% 100.00% 100.00% 100.00% 7.8.3 度数表と割合を同時に表示 adorn_nsという関数を使うと、度数と割合を同時に表示できる。 引数positionに “front”を指定すると割合が（）内に表示される “rear”を指定すると度数が（）内に表示される data_include_na %&gt;% tabyl(cut, color) %&gt;% adorn_totals(where = c(&quot;row&quot;, &quot;col&quot;)) %&gt;% adorn_percentages(denominator = &quot;col&quot;) %&gt;% adorn_pct_formatting(digits = 2) %&gt;% adorn_title(placement = &quot;combined&quot;, col_name = &quot;color&quot;) %&gt;% adorn_ns(position = &quot;front&quot;) %&gt;% as_tibble() %&gt;% DT::datatable( extensions = &#39;FixedColumns&#39;, options = list( dom = &#39;t&#39;, scrollX = TRUE, scrollCollapse = TRUE ) ) 7.9 関数化 2つの変数を入れるとクロス集計表が出てくるように関数化しておくと便利だろう。 （2重 curly brackets{{}}やenquoなどの黒魔術はスルーしてほしい） cross_tally &lt;- function(data, var1, var2, affix_sign_TF = TRUE, adorn_ns_TF = TRUE){ res &lt;- data %&gt;% tabyl({{var1}}, {{var2}}) %&gt;% adorn_totals(where = c(&quot;row&quot;, &quot;col&quot;)) %&gt;% adorn_percentages(denominator = &quot;col&quot;) %&gt;% adorn_pct_formatting(digits = 2, affix_sign = affix_sign_TF) %&gt;% adorn_title(placement = &quot;combined&quot;, row_name = as_label(enquo(var1)), col_name = as_label(enquo(var2))) if (adorn_ns_TF){ res &lt;- res %&gt;% adorn_ns(position = &quot;front&quot;) } return(as_tibble(res)) } data_include_na %&gt;% cross_tally(cut, color) # A tibble: 7 x 9 `cut/color` D E F G H I J Total &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; 1 Fair &quot; 136 (2~ &quot; 179 (1~ &quot; 243 (2~ &quot; 248 ~ &quot; 248 (~ &quot; 142 (~ &quot; 99 (~ &quot; 1295 ~ 2 Good &quot; 555 (8~ &quot; 756 (7~ &quot; 715 (7~ &quot; 689 ~ &quot; 572 (~ &quot; 425 (~ &quot; 245 (~ &quot; 3957 ~ 3 Ideal &quot;2284 (33~ &quot;3219 (32~ &quot;3124 (32~ &quot; 4000 (~ &quot;2518 (3~ &quot;1711 (3~ &quot; 738 (2~ &quot;17594 (~ 4 Premium &quot;1302 (19~ &quot;1919 (19~ &quot;1920 (20~ &quot; 2386 (~ &quot;1933 (2~ &quot;1181 (2~ &quot; 676 (2~ &quot;11317 (~ 5 Very Good &quot;1252 (18~ &quot;1936 (19~ &quot;1755 (18~ &quot; 1857 (~ &quot;1480 (1~ &quot; 968 (1~ &quot; 529 (1~ &quot; 9777 (~ 6 &lt;NA&gt; &quot;1246 (18~ &quot;1788 (18~ &quot;1785 (18~ &quot; 2112 (~ &quot;1553 (1~ &quot; 995 (1~ &quot; 521 (1~ &quot;10000 (~ 7 Total &quot;6775 (100~ &quot;9797 (100~ &quot;9542 (100~ &quot;11292 (1~ &quot;8304 (10~ &quot;5422 (10~ &quot;2808 (10~ &quot;53940 (1~ 7.10 可視化 7.10.1 モザイクプロット クロス集計表はモザイクプロットを使用して可視化することが多いが、結構見づらいことが多い。 df &lt;- data %&gt;% tabyl(cut, color) %&gt;% adorn_percentages(denominator = &quot;all&quot;) %&gt;% adorn_title(placement = &quot;combined&quot;, col_name = &quot;color&quot;) %&gt;% as_tibble() mat &lt;- df %&gt;% select(-`cut/color`) %&gt;% as.matrix() colnames(mat) &lt;- colnames(df %&gt;% select(-`cut/color`)) rownames(mat) &lt;- df$`cut/color` t(mat) %&gt;% mosaicplot(&quot;クロス集計&quot;) DTパッケージを使用して、テーブルのまま装飾を加えることできれいに可視化することができる。 7.10.2 通常のテーブル data_include_na %&gt;% tabyl(cut, color) %&gt;% adorn_totals(where = c(&quot;row&quot;, &quot;col&quot;)) %&gt;% adorn_percentages(denominator = &quot;all&quot;) %&gt;% adorn_title(placement = &quot;combined&quot;, col_name = &quot;color&quot;) %&gt;% as_tibble() %&gt;% mutate_if(is.double, round, 5) %&gt;% DT::datatable() 7.10.3 装飾を加えたテーブル 参考 https://kazutan.github.io/SappoRoR5/DT_demo.html https://rstudio.github.io/DT/010-style.html df &lt;- data %&gt;% tabyl(cut, color) %&gt;% adorn_percentages(denominator = &quot;all&quot;) %&gt;% adorn_title(placement = &quot;combined&quot;, col_name = &quot;color&quot;) %&gt;% as_tibble() df %&gt;% mutate_if(is.double, round, 5) %&gt;% DT::datatable() %&gt;% formatStyle(names(df), background = styleColorBar(range(df %&gt;% select(-`cut/color`)), &#39;lightblue&#39;), backgroundSize = &#39;98% 88%&#39;, backgroundRepeat = &#39;no-repeat&#39;, backgroundPosition = &#39;center&#39;) "]]
